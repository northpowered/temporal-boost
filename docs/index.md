# Getting started

## About the framework

Temporal-boost is a small framework, focused on fast and comfortable developing and deploying Temporal-based microservices. It based on standart Temporal SDK for Python, but offers FastAPI code organisation for developers.

### Main dependencies

- Temporal SDK (python)
- Pydantic - for serialization
- Typer - for comportable CLI interface
- Loguru - for extendind stardart logger
- Hypercorn - for running ASGI (read `FastAPI`) applications
- Robyn - for service purposes (auto-generated documentation)

### Main features

- FastAPI-style application with ability to add workers (like routers)
- Autogenerated documentation for workflows,activities, etc.
- Ð¡entralized logging and tracing management
- Simple usage of CRON workflows
- Ability to add external applications (ex. FastAPI) and deploy it in a separate container/pod

## Installation

```bash
poetry add temporal-boost
```

or

```bash
pip install temporal-boost
```

## Quick start

### Code example
> main.py

```python
from datetime import timedelta
from temporalio import activity, workflow

# Import `BoostApp` class
from temporal_boost import BoostApp, BoostLoggerConfig

# Create `BoostApp` object
app: BoostApp = BoostApp(
    logger_config=BoostLoggerConfig(
        json=True,
        bind_extra={"logging_extra_data": "foo_bar"}, 
        level="DEBUG"),
    use_pydantic=True,
)


# Describe your activities/workflows
@activity.defn(name="my_activity")
async def my_activity(name: str) -> str:
    return f"Hello, {name}!"

@workflow.defn(sandboxed=False, name="MyWorkflow")
class MyWorkflow:
    @workflow.run
    async def run(self, name: str) -> str:
        return await workflow.execute_activity(
            my_activity,
            name,
            task_queue="my_queue_1",
            start_to_close_timeout=timedelta(minutes=1),
        )

# Add async workers to your app
app.add_worker(
    "my_worker_1",
    "my_queue_1",
    activities=[my_activity],
    metrics_endpoint="0.0.0.0:9000",
    description="This workers serves activity my_activity on my_queue_1",
)
app.add_worker(
    "worker_2",
    "my_queue_2",
    workflows=[MyWorkflow]
)

app.add_internal_worker("0.0.0.0",8000, doc_endpoint="/doc")

app.run()
```
### Start example application

Starting all workers at once

```bash
python3 main.py run all
```

Starting workers one by one

```bash
python3 main.py run worker_1
python3 main.py run worker_2
```