# Getting started
![](https://socialify.git.ci/northpowered/temporal-boost/image?description=1&font=Source%20Code%20Pro&logo=https%3A%2F%2Fraw.githubusercontent.com%2Ftemporalio%2Fdocumentation%2Fmain%2Fstatic%2Fimg%2Ffavicon.svg&name=1&owner=1&pattern=Brick%20Wall&theme=Light)

## About the framework

Temporal-boost is a small framework, focused on fast and comfortable developing and deploying Temporal-based microservices. It based on standart Temporal SDK for Python, but offers FastAPI code organisation for developers.

### Main dependencies

- [x] [Temporal SDK (python)](https://github.com/temporalio/sdk-python)
- [x] [Pydantic - for serialization](https://github.com/pydantic/pydantic)
- [x] [Typer - for comportable CLI interface](https://github.com/fastapi/typer)
- [x] [Loguru - for extending stardart logger](https://github.com/Delgan/loguru)
- [x] [Hypercorn - for running ASGI (read `FastAPI`) applications](https://github.com/pgjones/hypercorn)
- [x] [Robyn - for service purposes (auto-generated documentation)](https://github.com/sparckles/Robyn)

### Main features

- [x] FastAPI-style application with ability to add workers (like routers)
- [x] Autogenerated documentation for workflows,activities, etc.
- [x] Ð¡entralized logging and tracing management
- [x] Simple usage of CRON workflows
- [x] Ability to add external applications (ex. FastAPI) and deploy it in a separate container/pod

## Installation

```bash
poetry add temporal-boost
```

or

```bash
pip install temporal-boost
```

## Quick start

### Code example
> main.py

```python
from datetime import timedelta
from temporalio import activity, workflow

# Import `BoostApp` class
from temporal_boost import BoostApp, BoostLoggerConfig

# Create `BoostApp` object
app: BoostApp = BoostApp(
    logger_config=BoostLoggerConfig(
        json=True,
        bind_extra={"logging_extra_data": "foo_bar"},
        level="DEBUG"),
    use_pydantic=True,
)


# Describe your activities/workflows
@activity.defn(name="my_activity")
async def my_activity(name: str) -> str:
    return f"Hello, {name}!"

@workflow.defn(sandboxed=False, name="MyWorkflow")
class MyWorkflow:
    @workflow.run
    async def run(self, name: str) -> str:
        return await workflow.execute_activity(
            my_activity,
            name,
            task_queue="my_queue_1",
            start_to_close_timeout=timedelta(minutes=1),
        )

# Add async workers to your app
app.add_worker(
    "my_worker_1",
    "my_queue_1",
    activities=[my_activity],
    metrics_endpoint="0.0.0.0:9000",
    description="This workers serves activity my_activity on my_queue_1",
)
app.add_worker(
    "worker_2",
    "my_queue_2",
    workflows=[MyWorkflow]
)

app.add_internal_worker("0.0.0.0",8000, doc_endpoint="/doc")

app.run()
```
### Start example application

Starting all workers at once

```bash
python3 main.py run all
```

Starting workers one by one

```bash
python3 main.py run worker_1
python3 main.py run worker_2
```
